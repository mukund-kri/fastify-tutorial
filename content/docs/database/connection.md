---
title: "Connect to a database"
weight: 41
---

# Adding a database to your project

Until now, we have been using a simple array to store the books. In a real world application, you will use a database to store the books. In this chapter, we will add a database to our project.

For convenience, we will use a SQLite database. SQLite is a file-based database. It is easy to use and does not require a separate server. In most real world applications, you will use a database server like MySQL or PostgreSQL. 

We'll leave the wiring of your code to a postgres database up to you as an exercise.

## Sequelize

We'll actually use a library called Sequelize to interact with the database. Sequelize is an ORM (Object Relational Mapper). It provides a simple API to interact with the database. It also provides a way to define the database schema.

Bootcamp Node: Go ahead and finish the Sequelize tutorial first. It is pre-requisite for this chapter.

Now let's add Sequelize to our project.

## Adding Sequelize to the project

As with any modern library, there are infinite ways to add Sequelize to your project. 
We'll the `sequelize-cli` utility to add Sequelize to our project.

### 1. Install `sequelize-cli`

```bash 
npm install --save-dev sequelize-cli
```

### 2. Initialize Sequelize

Let's add initial sequelize code to our project. Run the following command:

```bash
npx sequelize init
```

If everything goes well, you should see the following output:

```bash
Sequelize CLI [Node: 18.12.1, CLI: 6.6.0, ORM: 6.29.1]

Created "config/config.json"
Successfully created models folder at "/home/mukund/workarea/books/fastify-tutorial-code-bookapi/models".
Successfully created migrations folder at "/home/mukund/workarea/books/fastify-tutorial-code-bookapi/migrations".
Successfully created seeders folder at "/home/mukund/workarea/books/fastify-tutorial-code-bookapi/seeders".
```

Go ahead an explore the files/folders created by the `sequelize-cli` utility. We will
do a deep dive into these files in the current and next few chapters.

## Diversion: The node module system

Before we go ahead and add the database code, let's take a quick detour into the node 
module system and the mess it is currently in. It begins with javascript being a
language that was designed to run in the browser. It was never designed to run on
the server. The node module system was added to the language to make it run on the
server. It was a hack.

There are many modules systems in javascript. The most popular ones are commonjs and
es6 modules. Initially, node used commonjs modules and it is the default to this
day. Node also supports es6 modules and we can set any node project to esm (es6 modules)
by adding the following line to the `package.json` file:

```json
"type": "module"
```

This all seems fine and dandy. But there is a problem. In the wider world of npm 
packages there are some packages that use commonjs modules and some that use esm.

In our books api project, we run into this problem. All our code was written in esm.
But the code generated by the `sequelize-cli` utility uses commonjs modules. This
means that we cannot use the code generated by the `sequelize-cli` utility in our
esm code.

There are many ways to solve this problem:

1. Rewrite the project in commonjs modules. Re-factoring code is hard. Let's not do this.
2. Write sequelize code in esm. Then we loose the convenience of using the 
   `sequelize-cli` utility, which quite handy especially when you are starting out.
   We also loose the ability to use the `sequelize-cli` utility to generate migrations.
   (we'll see what migrations are in the next chapter). 
3. We can mix commonjs module with esm. In our projects any files with the `.cjs` extension
   will be treated as commonjs modules. So we just rename the files generated by the
    `sequelize-cli` utility to `.cjs` and we are good to go. 

Yes! the third option is the least elegant will not be used in production code. But
here we are using it for learning purposes. So we'll rename any file generated by 
`sequelize-cli` form `.js` to `.cjs`.

### Back to: Initializing sequelize

As per our previous discussion, we'll rename the files generated by `sequelize-cli`:
    
```bash 
mv models/index.js models/index.cjs
mv migrations/index.js migrations/index.cjs
mv seeders/index.js seeders/index.cjs
```

### 3. Configure Sequelize

Now, we have tell sequelize which database to use. We'll use SQLite as it is the 
easiest. SQLite is almost never used in production, but it easy to use hence easy
to learn. So keep that in mind.

Open the `config/config.json` an change the content to ...

```json
{
  "development": {
    "dialect": "sqlite",
    "storage": "./db.development.sqlite"
  },
  "test": {
    "dialect": "sqlite",
    "storage": ":memory:"
  },
  "production": {
    "dialect": "sqlite",
    "storage": "./db.production.sqlite"
  }
}
```

A more detailed explanation of this is in the sequelize docs.

### 5. The Book model

Now, we'll create a model for the book. A model is a representation of a table in
the database. We'll use the `sequelize-cli` utility to create the model.

```bash
npx sequelize model:generate --name Book --attributes title:string,author:string,price:decimal
```


This will create a file `models/book.js` and a migration file `migrations/20201204100000-create-book.js`.

Let's look at the model file first. It will look something like this:

```js
```

### 6. The Book migration


### 7. Wiring up REST api with the database

## Summary

## Exercises



{{<pagebottomnav>}}